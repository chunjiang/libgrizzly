/*
 ============================================================================
 Name        : libgrizzly.c
 Author      : 
 Version     :
 Copyright   : Your copyright notice
 Description : Hello World in C, Ansi-style
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <libusb-1.0/libusb.h>
#include "libgrizzly.h"

/**
 * Checks whether the given device corresponds to a grizzly.
 * @param dev The device found by libusb that could be a grizzly.
 * @return An integer, 1 if @dev is a grizzly, 0 otherwise.
 */
int is_grizzly(libusb_device *dev) {
	struct libusb_device_descriptor desc;
	int r = libusb_get_device_descriptor(dev, &desc);
	if (r < 0) {
		printf("Failed to get description\n");
		return -1;
	}
	return (desc.idVendor == IDVENDOR) & (desc.idProduct == IDPRODUCT);
}

/**
 * Low level wrapper over the libusb_control_transfer. Sends data to the device
 * for writing.
 * @param dev The device data is being written to.
 * @param cmd A byte string "packet". Packet format looks like:
 *       Byte 0:           Register
 *       Byte 1 (bit 6:0): Length of data to read/write
 *       Byte 1 (bit 7):   R/W flag (1 = write)
 *       Byte 2-15:        Data
 * @return If positive, the number of bytes written. If negative, some sort of error.
 */
int grizzly_send_bytes(libusb_device_handle* dev, unsigned char* cmd) {
	return libusb_control_transfer(dev, 0x21, 0x09, 0x0300, 0, cmd, 16, DEFAULT_TIMEOUT);
}

/**
 * Low level wrapper over the libusb_control_transfer. Sends a request for data from the device
 * and reads back the data.
 * @param dev The device data is being read from.
 * @param cmd The request packet, of the same structure as for grizzly_send_bytes. Only relevant
 * data here is which register, and length of read.
 * @param rtn The array the read data will be saved to. Should be appropriately sized for the read.
 * @return The amount of real data read from device in bytes.
 */
int grizzly_exchange_bytes(libusb_device_handle* dev, unsigned char* cmd, unsigned char* rtn) {
	int err = grizzly_send_bytes(dev, cmd); // Setup read
	if (err < 0) {
		return err;
	}

	uint16_t num_bytes = cmd[1] & 0x7f;
	unsigned char temp[num_bytes + 1];
	// Read data. Need to throw away the first byte from the transfer.
	err = libusb_control_transfer(dev, 0xa1, 0x01, 0x0301, 0, temp, num_bytes + 1, DEFAULT_TIMEOUT);

	for (int i = 0; i < num_bytes; i++) {
		rtn[i] = temp[i + 1];
	}
	if (err < 0) {
		return err;
	}
	return num_bytes;
}

/**
 * Helper function to poll all detected usb devices and record the ones identified as grizzlies. Usually
 * do not use this directly unless you want all grizzlies to do the same actions. You must also close
 * all your unused grizzlies manually.
 * @param ctx The libusb_context of the environment.
 * @param handles The array the discovered grizzlies will be returned in. Allocated earlier in the stack
 * and usually we assume less than 10 grizzlies will be connected at once.
 * @return The number of grizzlies discovered. Negative if error. @handles can be assumed to be valid
 * up to this value.
 */
ssize_t get_all_grizzlies(libusb_context* ctx, libusb_device_handle** handles) {
	libusb_device **list;
	ssize_t cnt = libusb_get_device_list(ctx, &list);
	printf("%d Devices\n", (int)cnt);

	ssize_t grizzly_count = 0, i;
	for (i = 0; i < cnt; ++i) {
		if (is_grizzly(list[i])) { // Prepare verified grizzlies for use.
			libusb_device_handle* current_handle;
			int err = libusb_open(list[i], &current_handle);
			if (err) {
				printf("Failed to open grizzly because %d\n", err);
				return -1;
			}

			err = 0;
			err = libusb_detach_kernel_driver(current_handle, 0);
			if (err) {
				printf("Failed to detach kernel driver\n");
			}

			handles[grizzly_count++] = current_handle;
		}
	}
	//Clean up usb devices we won't be using.
	printf("%d Grizzlies detected\n", (int)grizzly_count);
	libusb_free_device_list(list, 1);
	return grizzly_count;
}

/**
 * Looks for a grizzly with a specific address.
 * @param ctx The libusb_context to look in.
 * @param addr The address of the grizzly you are looking for.
 * @return The handle to the grizzly with the specified address. Returns NULL if not found.
 */
libusb_device_handle* find_grizzly(libusb_context* ctx, unsigned char addr) {
	libusb_device_handle* handles[10];
	ssize_t num = get_all_grizzlies(ctx, handles);

	for (int i = 0; i < num; i++) {
		unsigned char internal_addr = grizzly_read_single_register(handles[i], ADDR_ADDRESSLIST);
		if (addr == internal_addr >> 1) {
			printf("Successfully opened and detached\n");
			return handles[i];
		} else {
			libusb_attach_kernel_driver(handles[i], 0);
			libusb_close(handles[i]);
		}
	}
	return NULL;
}

/**
 * Finds and prepares a grizzly with the specified address for USB control. This is like the
 * constructor.
 * @param ctx The libusb_context generated by libusb_init.
 * @param device_addr The address of the grizzly you are looking for.
 * @return The handle of the opened grizzly with the specific address. NULL if not found.
 */
libusb_device_handle* grizzly_init(libusb_context* ctx, unsigned char device_addr) {
	libusb_device_handle* device = find_grizzly(ctx, device_addr);
	if (device == NULL) {
		printf("Could not find grizzly\n");
		return NULL;
	}
	grizzly_write_as_int(device, ADDR_ENABLEUSB, 1, 1);
	return device;
}

/**
 * High level, general purpose function. Writes data to a specific register and up to 13 registers after it.
 * @param dev The device to write to.
 * @param addr The starting i2c address to write to.
 * @param data The data to write to @addr and after, if any.
 * @param num The number of bytes being written to registers.
 */
void grizzly_write_registers(libusb_device_handle* dev, unsigned char addr, unsigned char* data, int num) {
	if (num > 14) {
		printf("Cannot write more than 14 bytes at a time.\n");
	} else {
		unsigned char buffer[16];
		for (int i = 2; i < 16; i++) {
			buffer[i] = 0;
		}
		buffer[0] = addr;
		buffer[1] = (unsigned char)num | 0x80;
		for (int i = 0; i < num; i++) {
			buffer[i + 2] = data[i];
		}
		grizzly_send_bytes(dev, buffer);
		//printf("%d bytes written\n", cnt);
	}
}

/**
 * Convenience function. Commonly, we only need to set 1 register and this prototype is simpler for such a task.
 * @param dev The device being written to.
 * @param addr The i2c address being written to.
 * @param data The byte to be loaded into @addr on the device.
 */
void grizzly_write_single_register(libusb_device_handle* dev, unsigned char addr, unsigned char data) {
	grizzly_write_registers(dev, addr, &data, 1);
}

/**
 * High level, general purpose function. Reads back a series of registers from the device.
 * @param dev The device being read from.
 * @param addr The starting addres being read from.
 * @param data The storage location of the data read back from the device.
 * @param num The number of bytes being requested.
 */
void grizzly_read_registers(libusb_device_handle* dev, unsigned char addr, unsigned char* data, int num) {
	if (num > 127) {
		printf("Cannot read more than 127 bytes at a time.\n");
	} else {
		unsigned char buffer[16];
		for (int i = 2; i < 16; i++) {
			buffer[i] = 0;
		}
		buffer[0] = addr;
		buffer[1] = (unsigned char)(num & 0xff);

		for (int i = 0; i < num; i++) {
			buffer[i + 2] = (unsigned char)0;
		}

		grizzly_exchange_bytes(dev, buffer, data);
	}
}

/**
 * Conveniece function. Commonly we read only a single register. This prototype is simpler and more useful.
 * @param dev The device to be read from.
 * @param addr The address to be read from.
 * @return The byte stored at @addr.
 */
unsigned char grizzly_read_single_register(libusb_device_handle* dev, unsigned char addr) {
	unsigned char rtn;
	grizzly_read_registers(dev, addr, &rtn, 1);
	return rtn;
}

/**
 * Grizzlies are limited to 1-byte words but we use values greater than that sometimes, by combining
 * multiple consecutive registers. This is a convenience function that reads a series of registers
 * and combines them into a single number.
 * @param dev The device to read from.
 * @param addr The starting address to read from.
 * @param num The number of bytes to read and combine. The maximum is 4.
 * @return The combined data read from the device. Could be signed or unsigned.
 */
int grizzly_read_as_int(libusb_device_handle* dev, unsigned char addr, int num) {
	if (num > 4) {
		printf ("Cannot read int greater than 4 bytes. Truncating to 4.\n");
		num = 4;
	}
	unsigned char buf[num];
	grizzly_read_registers(dev, addr, buf, num);

	int rtn = 0;
	for (int i = 0; i < num; i++) {
		rtn |= (buf[i] << (8 * i));
	}
	return rtn;
}

/**
 * The complementary command to grizzly_read_as_int. Writes up to 4 registers on the device.
 * @param dev The device to write to.
 * @param addr The starting address to write to.
 * @param val The integer to split up into bytes and send to the device.
 * @param num The number of bytes to write to the device.
 */
void grizzly_write_as_int(libusb_device_handle* dev, unsigned char addr, int val, int num) {
	unsigned char buf[num];
	for (int i = 0; i < num; i++) {
		buf[i] = (val >> (8 * i)) & 0xff;
	}

	grizzly_write_registers(dev, addr, buf, num);
}

/**
 * API command to set the grizzly throttle in CMODE_NO_PID or encoder target in CMODE_SPEED_PID/CMOD_POSITION_PID.
 * @param dev The device on which to set the target.
 * @param setpoint The speed/position value to set.
 */
void grizzly_set_target(libusb_device_handle* dev, float setpoint) {
	int fixed_setpoint = float_to_fixed(setpoint);
	unsigned char buf[5];
	for (int i = 0; i < 5; i++) {
		buf[i] = (fixed_setpoint >> (8 * i)) & 0xff;
	}
	grizzly_write_registers(dev, ADDR_SPEED, buf, 5);
}

/**
 * Sets the drive configuration of the grizzly.
 * @param dev The device whose config you want to set.
 * @param cmode The command mode you want to use. Could be CMODE_NO_PID, CMODE_SPEED_PID, CMODE_POSITION_PID.
 * @param dmode
 */
void grizzly_set_mode(libusb_device_handle* dev, char cmode, char dmode) {
	unsigned char mode = grizzly_read_single_register(dev, ADDR_MODE_RO);
	mode &= 0x01; // Get enable bit
	mode |= cmode | dmode;
	grizzly_write_single_register(dev, ADDR_MODE, mode);
	grizzly_write_single_register(dev, ADDR_UPDATE, 0);
}

/**
 * Reads the current passing through the motor.
 * @param dev The device whose current you want to read.
 * @return The current being measured by the grizzly in amps.
 */
float grizzly_read_current(libusb_device_handle* dev) {
	int raw_adc = grizzly_read_as_int(dev, ADDR_MOTORCURRENT, 2);
	return (5.0 / 1024.0) * (1000.0 / 66.0) * (raw_adc - 511);
}

/**
 * Reads the current encoder count from the grizzly.
 * @param dev The device to read from.
 * @return A signed integer representing how many counts the encoder has detected.
 */
int grizzly_read_encoder(libusb_device_handle* dev) {
	return grizzly_read_as_int(dev, ADDR_ENCODERCOUNT, 4);
}

/**
 * Sets the internal encoder count of the grizzly.
 * @param dev The device to set.
 * @param new_val The new value to be stored on the grizzly.
 */
void grizzly_write_encoder(libusb_device_handle* dev, int new_val) {
	grizzly_write_as_int(dev, ADDR_ENCODERCOUNT, new_val, 4);
}

/**
 * Sets the acceleration limit of the grizzly. Defined as the change in pwm timer values per ms.
 * @param dev The device to set the acceleration limit of.
 * @param new_val The new value of acceleration limit to set.
 */
void grizzly_limit_acceleration(libusb_device_handle* dev, int new_val) {
	if (new_val > 142) {
		printf("Acceleration limit cannot exceed 142. Clamping value to 142.\n");
		new_val = 142;
	}
	if (new_val <= 0) {
		printf("Acceleration limit must be positive. Clamping value to 0.");
		new_val = 0;
	}

	grizzly_write_as_int(dev, ADDR_ACCELLIMIT, new_val, 1);
}

/**
 * Sets the current limit of the grizzly.
 * @param dev The device to set the current limit of.
 * @param new_val The new value of current limit to set in amps.
 */
void grizzly_limit_current(libusb_device_handle* dev, int new_val) {
	if (new_val <= 0) {
		printf("Current limit must be a positive number. Clamping value to 0.");
		new_val = 0;
	}

	int adc_val = (int)(new_val * (1024.0 / 5.0) * (66.0 / 1000.0));
	grizzly_write_as_int(dev, ADDR_CURRENTLIMIT, adc_val, 2);
}

/**
 * Set all the PID constants at once.
 * @param dev The device to set the constants for.
 * @param kp The proportional term.
 * @param ki The integral term.
 * @param kd The derivative term.
 */
void grizzly_init_pid(libusb_device_handle* dev, float kp, float ki, float kd) {
	int p = float_to_fixed(kp);
	int i = float_to_fixed(ki);
	int d = float_to_fixed(kd);

	grizzly_write_as_int(dev, ADDR_PCONSTANT, p, 4);
	grizzly_write_as_int(dev, ADDR_ICONSTANT, i, 4);
	grizzly_write_as_int(dev, ADDR_DCONSTANT, d, 4);
}

/**
 * Reads back all the currently set PID constants.
 * @param dev The device to read constants from.
 * @param constants The array to return the values in. Should be 3 * sizeof(float).
 */
void grizzly_read_pid_constants(libusb_device_handle* dev, float* constants) {
	int p = grizzly_read_as_int(dev, ADDR_PCONSTANT, 4);
	int i = grizzly_read_as_int(dev, ADDR_ICONSTANT, 4);
	int d = grizzly_read_as_int(dev, ADDR_DCONSTANT, 4);

	constants[0] = fixed_to_float(p);
	constants[1] = fixed_to_float(i);
	constants[2] = fixed_to_float(d);
}

/**
 * Converts a grizzly address like 0x0f into an id like 0.
 * @param addr A char representing an address of a grizzly.
 * @return The corresponding id to the given address.
 */
unsigned char grizzly_addr_to_id(unsigned char addr) {
	return 0x0f - addr;
}

/**
 * Converts a grizzly id like 0 into an address like 0x0f.
 * @param id A char representing the id of a grizzly.
 * @return The corresponding address to the given id.
 */
unsigned char grizzly_id_to_addr(unsigned char id) {
	return 0x0f - id;
}

/**
 * Enables the grizzly to drive. This must be called before any movement happens.
 * @param dev The grizzly to enable.
 * @return Whether the enable command was successful or not. 1 if successfull, 0 otherwise.
 */
int grizzly_enable(libusb_device_handle* dev) {
	unsigned char mode = grizzly_read_single_register(dev, ADDR_MODE_RO);
	mode |= 0x01;
	grizzly_write_single_register(dev, ADDR_MODE, mode);
	grizzly_write_single_register(dev, ADDR_UPDATE, 0x00);
	mode = grizzly_read_single_register(dev, ADDR_MODE_RO);

	return mode & 0x01;
}

/**
 * Disables the grizzly from driving. Assumed to always be successful.
 * @param dev The grizzly to disable.
 */
void grizzly_disable(libusb_device_handle* dev) {
	unsigned char mode = grizzly_read_single_register(dev, ADDR_MODE_RO);
	mode &= (0xff - 0x01);
	grizzly_write_single_register(dev, ADDR_MODE, mode);
}

/**
 * Disables and closes the grizzly. To be used to clean up used resources.
 * @param grizzly The grizzly to close.
 */
void grizzly_exit(libusb_device_handle* grizzly) {
	grizzly_disable(grizzly);
	libusb_attach_kernel_driver(grizzly, 0);
	libusb_close(grizzly);
}

/**
 * Frees all the grizzlies and cleans up all the resources used.
 * @param ctx The libusb_context used to find the grizzlies.
 * @param all_handles A list of all the grizzly handles used.
 * @param num_devices The number of devices that need to be freed.
 * @param error The error code to be returned.
 * @return The error code (if any).
 */
int grizzly_cleanup_all(libusb_context* ctx, libusb_device_handle** all_handles, int num_devices, int error) {
	for (int i = 0; i < num_devices; i++) {
		grizzly_exit(all_handles[i]);
	}
	libusb_exit(ctx);
	return error;
}

float fixed_to_float(int fixed) {
	return fixed / 65536.0;
}

int float_to_fixed(float f) {
	return (int)(f * 65536.0);
}
